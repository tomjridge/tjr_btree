<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Tjr_btree__Tjr_btree_doc (tjr_btree.Tjr_btree__Tjr_btree_doc)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="generator" content="doc-ock-html v1.0.0-1-g1fc9bf0"/></head><body><nav id="top"><a href="../index.html">Up</a> &mdash; <span class="package">package <a href="../index.html">tjr_btree</a></span></nav><header><h1><span class="keyword">Module</span> <span class="module-path">Tjr_btree__Tjr_btree_doc</span></h1></header><p>Main documentation entry point.</p><p>This file contains general documentation and an overview of the
code. Follow the links to individual modules for more information.</p><h2>Introduction</h2><p>This library implements a B-tree in OCaml. The source is actually
exported from Isabelle, and then OCaml code wraps the
Isabelle-generated code. This is the documentation for the OCaml
wrapper. The documentation for the core B-tree routines can be found
in the <code class="code">isa_btree</code> repository.</p><p>This document gives an overview of the (sub)packages and a guide to
the structure of the code. Detailed
comments are included in the individual modules.</p><h2>Ancestor projects</h2><p>See the <code class="code">README.org</code> in the project root directory for a list of
dependencies.</p><h2>Directory structure</h2><p>The code is organized into subdirectories (subpackages), and the
subdirectories are in a linear order (which corresponds to the
dependencies between modules). For example, the first subdirectory
(ignoring <code class="code">aa_from_isa</code> since it is not used) is <code class="code">ac_test</code> which is
discussed in the section &quot;Test&quot; below.</p><h2>Naming conventions</h2><p>To understand the interfaces, we need to introduce the following:</p><ul><li>Keys, represented by type variable <code class="code">'k</code></li><li>Values, type var <code class="code">'v</code></li><li>Page/block references, <code class="code">'r</code></li><li>Global state, <code class="code">'t</code></li></ul><h2>Monads!</h2><p>The entire development is parameterized by some notion of
monad. Before reading the rest of the documentation, please look at
the module Tjr_monad from ancestor project <code class="code">tjr_monad</code>. Essentially
we use a type <code class="code">('a,'t) m</code>, where <code class="code">'t</code> is some phantom type var that is
used to identify a particular monad instance. There is an associated
type <code class="code">'t monad_ops</code> which provides the expected return and bind. In
order to get parametricity over the monad, we are forced to pass
<code class="code">monad_ops</code> as parameters to many functions.</p><h2>Exported code from Isabelle</h2><p>Exported code is in the <code class="code">isa_btree</code> opam/ocamlfind package. The
<code class="code">from_isa</code> package here is not used. FIXME</p><h2>Test</h2><p>Some simple testing utility functions.</p><h2>Base types</h2><p>This package contains basic B-tree related types:</p><ul><li>Base_types includes most of the other modules in this package</li><li>Base_types_pervasives which includes utility functions assumed by
the other modules</li><li>Block for blocks on disk</li><li>Constants which give size constraints on B-tree nodes FIXME now
in isa_btree</li><li>Frame which imports the Isabelle frame type</li><li>Ls_state for the leaf stream state</li><li>Ord for orderings (typically over keys)</li><li>Params for various projection functions from a &quot;parameters&quot; object</li><li>R2f and R2t for internal types used in testing (convert a
block ref to a frame/tree)</li><li>Rstk for the type of framestacks</li><li>String_ for various string utility functions</li><li>Tree for the tree type imported from Isabelle</li></ul><p>The Tree module describes a B-tree as an algebraic datatype. The
on-disk B-tree uses references between blocks i.e. a graph-like
structure with pointers rather than a datatype. Indeed, the tree
datatype is used only for testing purposes.</p><h2>Api</h2><p>This package gives the main interface types, including interfaces for
disk, store and map.</p><ul><li>Disk_ops for the low-level block interface</li><li>Leaf_stream_ops and Leaf_stream_util for leaf streams</li><li>Map_ops for map operations, find etc.</li><li>Page_ref_int utility module to fix page ref as an integer</li><li>Pre_map_ops like Map_ops but with explicit state passing</li><li>Store_ops for a layer just above Disk_ops</li></ul><p>In addition, the leaf stream interface allows to iterate over the
leaves in a B-tree e.g. to find all the bindings in the map. This
module also documents the type variable naming conventions (see
Map_ops).</p><p><b>Important note on code style:</b> Interfaces are essentially groups of
polymorphic functions, collected together and named using a record
type. For example, map operations are something of the form
<code class="code">('k,'v,'t) map_ops</code>. To get a handle on the components of such a
thing we provide functions such as <span class="xref-unresolved" title="unresolved reference to &quot;Map_ops.dest_map_ops&quot;">Map_ops.dest_map_ops</span> which takes
a set of map operations and a &quot;continuation&quot; function and calls the
function with the components of the record. Example code should make
this clearer:</p><pre>dest_imperative_map_ops map_ops @@ fun ~find ~insert ~delete -&gt;
  (* write values *)
  for x=1 to max do
    insert (k x) (v x);
  done;</pre><h2>Store to map</h2><p>This package, particularly the Store_to_map module, wraps the
Isabelle routines to implement a map interface on top of a
store. The key function is <span class="xref-unresolved" title="unresolved reference to &quot;Store_to_map.store_ops_to_map_ops&quot;">Store_to_map.store_ops_to_map_ops</span>
which takes a <code class="code">store_ops</code> and returns a <code class="code">map_ops</code>.</p><p>Also included here are Big_step (to iterate the small step
operations provided by Isabelle) and Iter_leaf_stream (to wrap
small-step leaf stream operations).</p><h2>Disks</h2><p>Disk_on_fd is a persistent block device on top of a &quot;normal&quot; file.</p><p>Disk_to_store includes a function that naively transforms a disk
to a store.</p><h2>Stores</h2><p>Mem_store is an in-memory store.</p><p>Recycling_store is a store that optimizes page alloc and free to
avoid too many unnecessary writes. Currently commented out. FIXME?</p><h2>Binprot marshalling</h2><p>Binprot_marshalling provides on-disk marshalling courtesy of
<code class="code">binprot</code>. You can, of course, provide your own marshalling code,
which may be useful if your backend doesn't support binprot (js_of_ocaml?)</p><h2>Cache</h2><p>A generic LRU Cache on top of a map. This is rather more
sophisticated than usual because we have to do various things when
cache entries (eg uncommitted disk operations) are flushed.</p><h2>Examples</h2><p>Various examples.</p><p>Bin_prot_util is a very small module which defines eg
<code class="code">bp_size_int</code>.</p><p>Bytestore provides a mechanism to store arbitrary length byte
buffers on top of a store. Currently commented out. FIXME?</p><p>Digest_ provides a digest/hash of a string, for situations where a
string is used as a key, but the exact contents of the string is not needed.</p><p>Examples_common</p><p>Map_int_blk provides a map from blk index to blk</p><p>Map_int_blkx provides a map from blk index to (partial) blk (i.e.,
only the first part of the blk is used).</p><p>Map_int_int provides a map from int to int, using <code class="code">binprot</code>
marshalling.</p><p>Map_on_fd is a generic map backed by a file descriptor.</p><p>Mem_map is a generic map on top of the Mem_store.</p><p>Small_string provides a string with a max size of 256 bytes
(using arbitrary length strings as keys requires another approach).</p><p>Ss_ss_map_on_fd implements an on-disk map from small string to
small string.</p><h2>Testing</h2><p>Various modules to support testing. Some of this looks a bit
suspicious. FIXME</p><h2>Doc</h2><p>Contains this overview documentation in module Tjr_btree_doc.</p><div class="spec val" id="val-dummy"><a href="#val-dummy" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>dummy : int</code></div><div class="doc"></div></div></body></html>