<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Tjr_btree_doc (tjr_btree.Tjr_btree.Tjr_btree_doc)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">tjr_btree</a> &#x00BB; <a href="../index.html">Tjr_btree</a> &#x00BB; Tjr_btree_doc</nav><h1>Module <code>Tjr_btree.Tjr_btree_doc</code></h1></header><aside><p>Main documentation entry point.</p></aside><aside><p>This file contains general documentation and an overview of the code. Follow the links to individual modules for more information.</p></aside><section><header><h2 id="introduction"><a href="#introduction" class="anchor"></a>Introduction</h2><p>This library implements a B-tree in OCaml. The source is actually exported from Isabelle, and then OCaml code wraps the Isabelle-generated code. This is the documentation for the OCaml wrapper. The documentation for the core B-tree routines can be found in the <code>isa_btree</code> repository.</p><p>This document gives an overview of the (sub)packages and a guide to the structure of the code. Detailed comments are included in the individual modules.</p></header></section><section><header><h2 id="ancestor-projects"><a href="#ancestor-projects" class="anchor"></a>Ancestor projects</h2><p>See the <code>README.org</code> in the project root directory for a list of dependencies.</p></header></section><section><header><h2 id="directory-structure"><a href="#directory-structure" class="anchor"></a>Directory structure</h2><p>The code is organized into subdirectories (subpackages), and the subdirectories are in a linear order (which corresponds to the dependencies between modules). For example, the first subdirectory is <code>a_test</code> which is discussed in the section &quot;Test&quot; below.</p><pre><code class="ml">./examples
     int_int_map_example_functionality.ml
     int_int_map_main.ml
     string_string_map_example_functionality.ml
     string_string_map_main.ml
./src/a_test
     isa_test.ml
     test.ml
./src/b_base_types
     base_types.ml
     blk_allocator_ops_type.ml
     block.ml
     config.ml
     frame.ml
     internal_base_types_pervasives.ml
     ls_state.ml
     marshalling_ops_type.ml
     ord.ml
     page_ref_int.ml
     r2f.ml
     r2t.ml
     rstk.ml
     string_.ml
     tree.ml
./src/c_api
     leaf_stream_ops.ml
     leaf_stream_util.ml
     pre_map_ops_type.ml
     store_ops.ml
./src/d_store_to_map
     big_step.ml
     iter_leaf_stream.ml
     store_to_map.ml
./src/e_disk_to_store
     disk_to_store.ml
./src/i_examples
     bin_prot_marshalling.ml
     bin_prot_util.ml
     examples.ml
     map_on_fd_util.ml
     store_in_mem.ml
./src/j_test
     default_filename.ml
     fixme_test_bytestore.ml
     test_exhaustive_in_mem.ml
     test_strings.ml
     tree_store.ml
./src/n_doc
     tjr_btree_doc.ml</code></pre></header></section><section><header><h2 id="naming-conventions"><a href="#naming-conventions" class="anchor"></a>Naming conventions</h2><p>To understand the interfaces, we need to introduce the following:</p><ul><li>Keys, represented by type variable <code>'k</code></li><li>Values, type var <code>'v</code></li><li>Page/block references, <code>'r</code></li><li>Global state, <code>'t</code></li></ul></header></section><section><header><h2 id="monads!"><a href="#monads!" class="anchor"></a>Monads!</h2><p>The entire development is parameterized by some notion of monad. Before reading the rest of the documentation, please look at the module <code>Tjr_monad</code> from ancestor project <code>tjr_monad</code>. Essentially we use a type <code>('a,'t) m</code>, where <code>'t</code> is some phantom type var that is used to identify a particular monad instance. There is an associated type <code>'t monad_ops</code> which provides the expected return and bind. In order to get parametricity over the monad, we are forced to pass <code>monad_ops</code> as parameters to many functions.</p></header></section><section><header><h2 id="exported-code-from-isabelle"><a href="#exported-code-from-isabelle" class="anchor"></a>Exported code from Isabelle</h2><p>Exported code is in the <code>isa_btree</code> opam/ocamlfind package.</p></header></section><section><header><h2 id="test"><a href="#test" class="anchor"></a>Test</h2><p>Some simple testing utility functions.</p></header></section><section><header><h2 id="base-types"><a href="#base-types" class="anchor"></a>Base types</h2><p>This package contains basic B-tree related types:</p><ul><li><a href="../Base_types/index.html"><code>Base_types</code></a> includes most of the other modules in this package the other modules</li><li><a href="../Blk_allocator_ops_type/index.html"><code>Blk_allocator_ops_type</code></a></li><li><a href="../Block/index.html"><code>Block</code></a> for blocks on disk</li><li><a href="../Config/index.html"><code>Config</code></a></li><li><a href="../Frame/index.html"><code>Frame</code></a> which imports the Isabelle frame type</li><li><a href="../Internal_base_types_pervasives/index.html"><code>Internal_base_types_pervasives</code></a> which includes utility functions assumed by</li><li><a href="../Ls_state/index.html"><code>Ls_state</code></a> for the leaf stream state</li><li><a href="../Marshalling_ops_type/index.html"><code>Marshalling_ops_type</code></a></li><li><a href="../Ord/index.html"><code>Ord</code></a> for orderings (typically over keys)</li><li><a href="../Page_ref_int/index.html"><code>Page_ref_int</code></a> utility module to fix page ref as an integer</li><li><a href="../R2f/index.html"><code>R2f</code></a> and <a href="../R2t/index.html"><code>R2t</code></a> for internal types used in testing (convert a block ref to a frame/tree)</li><li><a href="../Rstk/index.html"><code>Rstk</code></a> for the type of framestacks</li><li><a href="../String_/index.html"><code>String_</code></a> for various string utility functions</li><li><a href="../Tree/index.html"><code>Tree</code></a> for the tree type imported from Isabelle</li></ul><p>The <a href="../Tree/index.html"><code>Tree</code></a> module describes a B-tree as an algebraic datatype. The on-disk B-tree uses references between blocks i.e. a graph-like structure with pointers rather than a datatype. Indeed, the tree datatype is used only for testing purposes.</p></header></section><section><header><h2 id="api"><a href="#api" class="anchor"></a>Api</h2><p>This package gives the main interface types, including interfaces for disk, store and map.</p><ul><li><a href="../Leaf_stream_ops/index.html"><code>Leaf_stream_ops</code></a> and <a href="../Leaf_stream_util/index.html"><code>Leaf_stream_util</code></a> for leaf streams</li><li><code>Pre_map_ops</code> like <code>Map_ops</code> but with explicit state passing</li><li><a href="../Store_ops/index.html"><code>Store_ops</code></a> for a layer just above <code>Disk_ops</code></li></ul><p>In addition, the leaf stream interface allows to iterate over the leaves in a B-tree e.g. to find all the bindings in the map. This module also documents the type variable naming conventions (see <code>Map_ops</code>).</p></header></section><section><header><h2 id="store-to-map"><a href="#store-to-map" class="anchor"></a>Store to map</h2><p>This package, particularly the <a href="../Store_to_map/index.html"><code>Store_to_map</code></a> module, wraps the Isabelle routines to implement a map interface on top of a store. The key function is <a href="../Store_to_map/index.html#val-store_ops_to_map_ops"><code>Store_to_map.store_ops_to_map_ops</code></a> which takes a <code>store_ops</code> and returns a <code>map_ops</code>.</p><p>Also included here are <a href="../Big_step/index.html"><code>Big_step</code></a> (to iterate the small step operations provided by Isabelle) and <a href="../Iter_leaf_stream/index.html"><code>Iter_leaf_stream</code></a> (to wrap small-step leaf stream operations).</p></header></section><section><header><h2 id="disk-to-store"><a href="#disk-to-store" class="anchor"></a>Disk to store</h2><p><a href="../Disk_to_store/index.html"><code>Disk_to_store</code></a> includes a function that naively transforms a disk to a store.</p></header></section><section><header><h2 id="examples"><a href="#examples" class="anchor"></a>Examples</h2><p>Various examples.</p><p><a href="../Bin_prot_marshalling/index.html"><code>Bin_prot_marshalling</code></a> provides on-disk marshalling courtesy of <code>binprot</code>. You can, of course, provide your own marshalling code, which may be useful if your backend doesn't support binprot (js_of_ocaml?)</p><p><a href="../Bin_prot_util/index.html"><code>Bin_prot_util</code></a> is a very small module which defines eg <code>bp_size_int</code>.</p><p><a href="../Examples/index.html"><code>Examples</code></a> contains the main constructions for various types of maps.</p><p><a href="../Map_on_fd_util/index.html"><code>Map_on_fd_util</code></a>, utilities for a map backed by a file descriptor.</p><p><a href="../Store_in_mem/index.html"><code>Store_in_mem</code></a> implements a simple in-memory store.</p></header></section><section><header><h2 id="testing"><a href="#testing" class="anchor"></a>Testing</h2><p>Various modules to support testing. Some of this looks a bit suspicious. The main module is <a href="../Test_exhaustive_in_mem/index.html"><code>Test_exhaustive_in_mem</code></a>.</p></header></section><section><header><h2 id="doc"><a href="#doc" class="anchor"></a>Doc</h2><p>Contains this overview documentation in module <a href="index.html"><code>Tjr_btree_doc</code></a>.</p></header><dl><dt class="spec value" id="val-dummy"><a href="#val-dummy" class="anchor"></a><code><span class="keyword">val </span>dummy : int</code></dt></dl></section></div></body></html>